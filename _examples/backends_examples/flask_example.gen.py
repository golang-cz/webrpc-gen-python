# example v0.0.1 a59ddf0f711919ffbfebf60c96453d534016372d
# --
# Code generated by webrpc-gen@v0.11.0 with custom generator. DO NOT EDIT.

# WebRPC description and code-gen version
WebRPCVersion = "v1"

# Schema version of your RIDL schema
WebRPCSchemaVersion = "v0.0.1"

# Schema hash generated from your RIDL schema
WebRPCSchemaHash = "a59ddf0f711919ffbfebf60c96453d534016372d"

#
# Imports
#
from enum import Enum
from abc import ABC, abstractmethod
from dataclasses import dataclass
import typing
#
# Types
#
@dataclass
class PingReturn(ABC):
    pass

@dataclass
class PingArgs(ABC):
    pass
@dataclass
class StatusReturn(ABC):
    pass

@dataclass
class StatusArgs(ABC):
    pass
@dataclass
class VersionReturn(ABC):
    pass

@dataclass
class VersionArgs(ABC):
    pass
@dataclass
class GetUserReturn(ABC):
    pass

@dataclass
class GetUserArgs(ABC):
    pass
@dataclass
class FindUserReturn(ABC):
    pass

@dataclass
class FindUserArgs(ABC):
    pass

class ExampleService(ABC):
    @abstractmethod
    def Ping(self, headers=dict()) -> PingReturn:
        pass
    @abstractmethod
    def Status(self, headers=dict()) -> StatusReturn:
        pass
    @abstractmethod
    def Version(self, headers=dict()) -> VersionReturn:
        pass
    @abstractmethod
    def GetUser(self, headers=dict()) -> GetUserReturn:
        pass
    @abstractmethod
    def FindUser(self, headers=dict()) -> FindUserReturn:
        pass


  
#
# Imports
#
import json
import requests

#
# Client
#
class ExampleServiceClient:
    def __init__(self, hostname):
        self.hostname = hostname
        self.path = '/rpc/ExampleService/'

    def url(self, name):
        return f"{self.hostname}{self.path}{name}"
    def ping(self, headers=dict()):
        url = self.url('Ping')
        headers = {'Content-Type': 'application/json'}
        body = json.dumps(PingArgs(headers=dict()).__dict__)

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return PingReturn(**response_data)
        except requests.exceptions.HTTPError as error:
            print(f"HTTP Error: {error}")
        except requests.exceptions.RequestException as error:
            print(f"Request Exception: {error}")
    def status(self, headers=dict()):
        url = self.url('Status')
        headers = {'Content-Type': 'application/json'}
        body = json.dumps(StatusArgs(headers=dict()).__dict__)

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return StatusReturn(**response_data)
        except requests.exceptions.HTTPError as error:
            print(f"HTTP Error: {error}")
        except requests.exceptions.RequestException as error:
            print(f"Request Exception: {error}")
    def version(self, headers=dict()):
        url = self.url('Version')
        headers = {'Content-Type': 'application/json'}
        body = json.dumps(VersionArgs(headers=dict()).__dict__)

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return VersionReturn(**response_data)
        except requests.exceptions.HTTPError as error:
            print(f"HTTP Error: {error}")
        except requests.exceptions.RequestException as error:
            print(f"Request Exception: {error}")
    def getUser(self, headers=dict()):
        url = self.url('GetUser')
        headers = {'Content-Type': 'application/json'}
        body = json.dumps(GetUserArgs(headers=dict()).__dict__)

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetUserReturn(**response_data)
        except requests.exceptions.HTTPError as error:
            print(f"HTTP Error: {error}")
        except requests.exceptions.RequestException as error:
            print(f"Request Exception: {error}")
    def findUser(self, headers=dict()):
        url = self.url('FindUser')
        headers = {'Content-Type': 'application/json'}
        body = json.dumps(FindUserArgs(headers=dict()).__dict__)

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return FindUserReturn(**response_data)
        except requests.exceptions.HTTPError as error:
            print(f"HTTP Error: {error}")
        except requests.exceptions.RequestException as error:
            print(f"Request Exception: {error}")
  
#
# Imports
#
import json
from typing import Any, Dict, Union

class WebRPCError(Exception):
    def __init__(self, code: str, msg: str, status: int) -> None:
        self.code = code
        self.msg = msg
        self.status = status

def create_http_request(body: Dict[str, Any] = {}, headers: Dict[str, Any] = {}) -> Dict[str, Any]:
    return {
        "method": "POST",
        "headers": {**headers, "Content-Type": "application/json"},
        "body": json.dumps(body)
    }

async def build_response(res: Union[Dict[str, Any], None]) -> Any:
    text = await res.text()
    try:
        data = json.loads(text)
    except json.JSONDecodeError:
        raise WebRPCError('unknown', f"expecting JSON, got: {text}", res.status) from None

    if not res.ok:
        raise data  # webrpc error response

    return data

#
# Imports
#
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Dict, Callable
#
# Server
#

class WebRPCError(Exception):
    def __init__(self, message, status_code=None):
        super().__init__(f"webrpc error: {message}")
        self.status_code = status_code

def validate_type(value, type):
    if type in ['null', 'any']:
        return True
    if type in ['byte', 'string', 'timestamp']:
        return isinstance(value, str)
    if type == 'bool':
        return isinstance(value, bool)
    if type in ['uint', 'uint8', 'uint16', 'uint32', 'uint64', 'int', 'int8', 'int16', 'int32', 'int64', 'float32', 'float64']:
        return isinstance(value, (int, float))
    if type == 'object':
        return isinstance(value, dict)
    if type.startswith('[]'):
        if not isinstance(value, list):
            return False
        elem_type = type[2:]
        return all(validate_type(item, elem_type) for item in value)
    if type in type_map:
        return validate_type(value, type_map[type])
    return False

type_map = {
    'null': 'None',
    'any': 'object',
    'byte': 'str',
    'bool': 'bool',
    'uint': 'int',
    'uint8': 'int',
    'uint16': 'int',
    'uint32': 'int',
    'uint64': 'int',
    'int': 'int',
    'int8': 'int',
    'int16': 'int',
    'int32': 'int',
    'int64': 'int',
    'float32': 'float',
    'float64': 'float',
    'string': 'str',
    'timestamp': 'str',
}

class WebRPCRequestHandler(BaseHTTPRequestHandler):
    def _parse_request_body(self):
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length).decode('utf-8')
        return json.loads(body) if body else {}

    def _send_response(self, response, status_code=200):
        self.send_response(status_code)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(response).encode('utf-8'))

    def _handle_rpc_request(self, service_name, method_name, request_body):
        service_impl = self.server.service_implementation.get(service_name)
        if not service_impl:
            raise WebRPCError(f"Service '{service_name}' not found", 404)

        method_impl = getattr(service_impl, method_name, None)
        if not method_impl or not callable(method_impl):
            raise WebRPCError(f"Method '{method_name}' not found", 404)

        try:
            method_args = request_body.get('args', {})
            method_headers = request_body.get('headers', {})
            for arg_name, arg_type in service_impl.method_args.get(method_name, {}).items():
                if arg_name not in method_args:
                    if arg_name not in method_headers:
                        raise WebRPCError(f"Missing argument '{arg_name}'")
                    method_args[arg_name] = method_headers[arg_name]
                if not validate_type(method_args[arg_name], arg_type):
                    raise WebRPCError(f"Invalid argument '{arg_name}'")

            response = method_impl(method_args)

            method_returns = service_impl.method_returns.get(method_name, {})
            for return_name, return_type in method_returns.items():
                if return_name not in response:
                    raise WebRPCError("Internal server error", 500)
                if not validate_type(response[return_name], return_type):
                    raise WebRPCError("Internal server error", 500)

            self._send_response(response)
        except WebRPCError as err:
            status_code = err.status_code or 400
            response = {
                'msg': err.message,
                'status': status_code,
                'code': '',
            }
            self._send_response(response, status_code)
        except Exception as err:
            self._send_response(str(err), 400)

    def do_POST(self):
        path_parts = self.path.strip('/').split('/')
        if len(path_parts) != 2:
            self.send_error(404)
            return

        service_name, method_name = path_parts
        if not service_name or not method_name:
            self.send_error(404)
            return

        if self.headers.get('Content-Type') != 'application/json':
            self.send_error(415)
            return

        try:
            request_body = self._parse_request_body()
            self._handle_rpc_request(service_name, method_name, request_body)
        except Exception as err:
            self.send_error(400, str(err))

def create_server(service_implementation, hostname='localhost', port=8080):
    server_address = (hostname, port)
    server = HTTPServer(server_address, WebRPCRequestHandler)
    server.service_implementation = service_implementation
    return server



def create_ExampleService_app(service_implementation):
    return create_server(ExampleService(), service_implementation)


TYPE_VALIDATORS: typing.Dict[str, Callable[[any], bool]] = {}

TYPE_VALIDATORS = {
    
}

PY_TYPES = [
    "bool",
    "int",
    "float",
    "str",
    "list",
    "tuple",
    "dict",
    "NoneType"
]

def validate_type(value, type):
    if type in PY_TYPES:
        return isinstance(value, type)

    if type == "function":
        return callable(value)

    validator = TYPE_VALIDATORS.get(type)

    if not validator:
        return False

    return validator(value)