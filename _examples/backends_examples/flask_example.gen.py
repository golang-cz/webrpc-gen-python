# --
# Code generated by webrpc-gen@v0.11.0 with custom generator. DO NOT EDIT.

# WebRPC description and code-gen version
WebRPCVersion = "v1"

# Schema version of your RIDL schema
WebRPCSchemaVersion = "v0.10.0"

# Schema hash generated from your RIDL schema
WebRPCSchemaHash = "7007c2ec8ccd58e0d4e9451d42e35be10140b8eb"

#
# Imports
#
from enum import Enum
from abc import ABC, abstractmethod
from dataclasses import dataclass
import typing
import json
#
# Types
#

class Status(Enum):
  AVAILABLE = 'AVAILABLE',
  NOT_AVAILABLE = 'NOT_AVAILABLE'

class Simple:
    def __init__(self, 
        id,
        name,
    ):
        self.id = id
        self.name = name
    def to_dict(self):
        return {
        "id" : self.id,
        "name" : self.name,
        }
        


class User:
    def __init__(self, 
        id,
        username,
        role,
    ):
        self.id = id
        self.username = username
        self.role = role
    def to_dict(self):
        return {
        "id" : self.id,
        "username" : self.username,
        "role" : self.role,
        }
        


class Complex:
    def __init__(self, 
        meta,
        metaNestedExample,
        namesList,
        numsList,
        doubleArray,
        listOfMaps,
        listOfUsers,
        mapOfUsers,
        user,
        enum,
    ):
        self.meta = meta
        self.metaNestedExample = metaNestedExample
        self.namesList = namesList
        self.numsList = numsList
        self.doubleArray = doubleArray
        self.listOfMaps = listOfMaps
        self.listOfUsers = listOfUsers
        self.mapOfUsers = mapOfUsers
        self.user = user
        self.enum = enum
    def to_dict(self):
        return {
        "meta" : self.meta,
        "metaNestedExample" : self.metaNestedExample,
        "namesList" : self.namesList,
        "numsList" : self.numsList,
        "doubleArray" : self.doubleArray,
        "listOfMaps" : self.listOfMaps,
        "listOfUsers" : self.listOfUsers,
        "mapOfUsers" : self.mapOfUsers,
        "user" : self.user,
        "enum" : self.enum,
        }
        


@dataclass
class GetEmptyArgs(ABC):
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetEmptyReturn(ABC):
    def to_dict(self):
        return {
        }
@dataclass
class GetErrorArgs(ABC):
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetErrorReturn(ABC):
    def to_dict(self):
        return {
        }
@dataclass
class GetOneArgs(ABC):
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetOneReturn(ABC):
    one: Simple
    def to_dict(self):
        return {
        "one" : self.one.to_dict(),
        }
@dataclass
class SendOneArgs(ABC):
    one: Simple
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class SendOneReturn(ABC):
    def to_dict(self):
        return {
        }
@dataclass
class GetMultiArgs(ABC):
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetMultiReturn(ABC):
    one: Simple
    two: Simple
    three: Simple
    def to_dict(self):
        return {
        "one" : self.one.to_dict(),
        "two" : self.two.to_dict(),
        "three" : self.three.to_dict(),
        }
@dataclass
class SendMultiArgs(ABC):
    one: Simple
    two: Simple
    three: Simple
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class SendMultiReturn(ABC):
    def to_dict(self):
        return {
        }
@dataclass
class GetComplexArgs(ABC):
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetComplexReturn(ABC):
    complex: Complex
    def to_dict(self):
        return {
        "complex" : self.complex.to_dict(),
        }
@dataclass
class SendComplexArgs(ABC):
    complex: Complex
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class SendComplexReturn(ABC):
    def to_dict(self):
        return {
        }
@dataclass
class GetSchemaErrorArgs(ABC):
    code: int
    def to_dict(self):
        return json.dumps(self, default=lambda o: o.__dict__)

@dataclass
class GetSchemaErrorReturn(ABC):
    def to_dict(self):
        return {
        }







#
# Imports
#
import json
import requests

#
# Client
#
class TestApi:
    def __init__(self, hostname):
        self.hostname = hostname
        self.path = '/rpc/TestApi/'

    def url(self, name):
        return f"{self.hostname}{self.path}{name}"
    def GetEmpty(self, args : GetEmptyArgs, headers=None):
        url = self.url('GetEmpty')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetEmptyReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def GetError(self, args : GetErrorArgs, headers=None):
        url = self.url('GetError')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetErrorReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def GetOne(self, args : GetOneArgs, headers=None):
        url = self.url('GetOne')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetOneReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def SendOne(self, args : SendOneArgs, headers=None):
        url = self.url('SendOne')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return SendOneReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def GetMulti(self, args : GetMultiArgs, headers=None):
        url = self.url('GetMulti')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetMultiReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def SendMulti(self, args : SendMultiArgs, headers=None):
        url = self.url('SendMulti')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return SendMultiReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def GetComplex(self, args : GetComplexArgs, headers=None):
        url = self.url('GetComplex')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetComplexReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def SendComplex(self, args : SendComplexArgs, headers=None):
        url = self.url('SendComplex')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return SendComplexReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
    def GetSchemaError(self, args : GetSchemaErrorArgs, headers=None):
        url = self.url('GetSchemaError')
        headers = {'Content-Type': 'application/json'} if not headers else headers
        body = json.dumps(args.to_dict())

        try:
            response = requests.post(url, headers=headers, data=body)
            response.raise_for_status()

            response_data = response.json()
            return GetSchemaErrorReturn(**response_data)
        except Exception as ex:
            print(ex)
            raise WebrpcRequestFailedError
def create_http_request(body=None, headers=None):
    if body is None:
        body = {}
    if headers is None:
        headers = {}
    headers["Content-Type"] = "application/json"
    return {
        "method": "POST",
        "headers": headers,
        "body": json.dumps(body),
    }

async def build_response(response):
    text = await response.text()
    try:
        data = json.loads(text)
    except Exception as error:
        raise WebrpcBadResponseError(
            status=response.status,
            cause=f"JSON.parse(): {str(error)}: response text: {text}"
        )
    if not response.ok:
        code = data.get("code", 0) if isinstance(data, dict) else 0
        raise (webrpc_error_by_code.get(code) or WebrpcError)(data)
    return data


class WebrpcError(Exception):
    def __init__(self, name=None, code=0, message=None, status=0, cause=None):
        super().__init__(message)
        self.name = name or "WebrpcError"
        self.code = code if isinstance(code, int) else 0
        self.message = message or f"endpoint error {self.code}"
        self.status = status if isinstance(status, int) else 0
        self.cause = cause

    @classmethod
    def new(cls, payload):
        return cls(
            payload.get("error"),
            payload.get("code", 0),
            payload.get("message") or payload.get("msg"),
            payload.get("status", 0),
            payload.get("cause"),
        )


# Webrpc errors

class WebrpcEndpointError(WebrpcError):
    def __init__(self, name="WebrpcEndpoint", code=0, message="endpoint error", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcRequestFailedError(WebrpcError):
    def __init__(self, name="WebrpcRequestFailed", code=-1, message="request failed", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcBadRouteError(WebrpcError):
    def __init__(self, name="WebrpcBadRoute", code=-2, message="bad route", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcBadMethodError(WebrpcError):
    def __init__(self, name="WebrpcBadMethod", code=-3, message="bad method", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcBadRequestError(WebrpcError):
    def __init__(self, name="WebrpcBadRequest", code=-4, message="bad request", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcBadResponseError(WebrpcError):
    def __init__(self, name="WebrpcBadResponse", code=-5, message="bad response", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class WebrpcServerPanicError(WebrpcError):
    def __init__(self, name="WebrpcServerPanic", code=-6, message="server panic", status=0, cause=None):
        super().__init__(name, code, message, status, cause)

# Schema errors

class UnauthorizedError(WebrpcError):
    def __init__(self, name="Unauthorized", code=1, message="unauthorized", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class ExpiredTokenError(WebrpcError):
    def __init__(self, name="ExpiredToken", code=2, message="expired token", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class InvalidTokenError(WebrpcError):
    def __init__(self, name="InvalidToken", code=3, message="invalid token", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class DeactivatedError(WebrpcError):
    def __init__(self, name="Deactivated", code=4, message="account deactivated", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class ConfirmAccountError(WebrpcError):
    def __init__(self, name="ConfirmAccount", code=5, message="confirm your email", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class AccessDeniedError(WebrpcError):
    def __init__(self, name="AccessDenied", code=6, message="access denied", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class MissingArgumentError(WebrpcError):
    def __init__(self, name="MissingArgument", code=7, message="missing argument", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class UnexpectedValueError(WebrpcError):
    def __init__(self, name="UnexpectedValue", code=8, message="unexpected value", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class RateLimitedError(WebrpcError):
    def __init__(self, name="RateLimited", code=100, message="too many requests", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class DatabaseDownError(WebrpcError):
    def __init__(self, name="DatabaseDown", code=101, message="service outage", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class ElasticDownError(WebrpcError):
    def __init__(self, name="ElasticDown", code=102, message="search is degraded", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class NotImplementedError(WebrpcError):
    def __init__(self, name="NotImplemented", code=103, message="not implemented", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class UserNotFoundError(WebrpcError):
    def __init__(self, name="UserNotFound", code=200, message="user not found", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class UserBusyError(WebrpcError):
    def __init__(self, name="UserBusy", code=201, message="user busy", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class InvalidUsernameError(WebrpcError):
    def __init__(self, name="InvalidUsername", code=202, message="invalid username", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class FileTooBigError(WebrpcError):
    def __init__(self, name="FileTooBig", code=300, message="file is too big (max 1GB)", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class FileInfectedError(WebrpcError):
    def __init__(self, name="FileInfected", code=301, message="file is infected", status=0, cause=None):
        super().__init__(name, code, message, status, cause)
class FileTypeError(WebrpcError):
    def __init__(self, name="FileType", code=302, message="unsupported file type", status=0, cause=None):
        super().__init__(name, code, message, status, cause)

errors = {
    "WebrpcEndpoint": "WebrpcEndpoint",
    "WebrpcRequestFailed": "WebrpcRequestFailed",
    "WebrpcBadRoute": "WebrpcBadRoute",
    "WebrpcBadMethod": "WebrpcBadMethod",
    "WebrpcBadRequest": "WebrpcBadRequest",
    "WebrpcBadResponse": "WebrpcBadResponse",
    "WebrpcServerPanic": "WebrpcServerPanic",
    "Unauthorized": "Unauthorized",
    "ExpiredToken": "ExpiredToken",
    "InvalidToken": "InvalidToken",
    "Deactivated": "Deactivated",
    "ConfirmAccount": "ConfirmAccount",
    "AccessDenied": "AccessDenied",
    "MissingArgument": "MissingArgument",
    "UnexpectedValue": "UnexpectedValue",
    "RateLimited": "RateLimited",
    "DatabaseDown": "DatabaseDown",
    "ElasticDown": "ElasticDown",
    "NotImplemented": "NotImplemented",
    "UserNotFound": "UserNotFound",
    "UserBusy": "UserBusy",
    "InvalidUsername": "InvalidUsername",
    "FileTooBig": "FileTooBig",
    "FileInfected": "FileInfected",
    "FileType": "FileType",
}

webrpc_error_by_code = {
    0: WebrpcEndpointError,
    -1: WebrpcRequestFailedError,
    -2: WebrpcBadRouteError,
    -3: WebrpcBadMethodError,
    -4: WebrpcBadRequestError,
    -5: WebrpcBadResponseError,
    -6: WebrpcServerPanicError,
    1: UnauthorizedError,
    2: ExpiredTokenError,
    3: InvalidTokenError,
    4: DeactivatedError,
    5: ConfirmAccountError,
    6: AccessDeniedError,
    7: MissingArgumentError,
    8: UnexpectedValueError,
    100: RateLimitedError,
    101: DatabaseDownError,
    102: ElasticDownError,
    103: NotImplementedError,
    200: UserNotFoundError,
    201: UserBusyError,
    202: InvalidUsernameError,
    300: FileTooBigError,
    301: FileInfectedError,
    302: FileTypeError,
}

async def fetch(input, init=None):
    response = await aiohttp.request("POST", input, headers=init.get("headers"), json=init.get("body"))
    return response

#
# Imports
#
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Dict, Callable
#
# Server
#

class WebRPCError(Exception):
    def __init__(self, message, status_code=None):
        super().__init__(f"webrpc error: {message}")
        self.status_code = status_code

def validate_type(value, type):
    if type in ['null', 'any']:
        return True
    if type in ['byte', 'string', 'timestamp']:
        return isinstance(value, str)
    if type == 'bool':
        return isinstance(value, bool)
    if type in ['uint', 'uint8', 'uint16', 'uint32', 'uint64', 'int', 'int8', 'int16', 'int32', 'int64', 'float32', 'float64']:
        return isinstance(value, (int, float))
    if type == 'object':
        return isinstance(value, dict)
    if type.startswith('[]'):
        if not isinstance(value, list):
            return False
        elem_type = type[2:]
        return all(validate_type(item, elem_type) for item in value)
    if type in type_map:
        return validate_type(value, type_map[type])
    return False

type_map = {
    'null': 'None',
    'any': 'object',
    'byte': 'str',
    'bool': 'bool',
    'uint': 'int',
    'uint8': 'int',
    'uint16': 'int',
    'uint32': 'int',
    'uint64': 'int',
    'int': 'int',
    'int8': 'int',
    'int16': 'int',
    'int32': 'int',
    'int64': 'int',
    'float32': 'float',
    'float64': 'float',
    'string': 'str',
    'timestamp': 'str',
}

class WebRPCRequestHandler(BaseHTTPRequestHandler):
    def _parse_request_body(self):
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length).decode('utf-8')
        return json.loads(body) if body else {}

    def _send_response(self, response, status_code=200):
        self.send_response(status_code)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(response).encode('utf-8'))

    def _handle_rpc_request(self, service_name, method_name, request_body):
        service_impl = self.server.service_implementation.get(service_name)
        if not service_impl:
            raise WebRPCError(f"Service '{service_name}' not found", 404)

        method_impl = getattr(service_impl, method_name, None)
        if not method_impl or not callable(method_impl):
            raise WebRPCError(f"Method '{method_name}' not found", 404)

        try:
            method_args = request_body.get('args', {})
            method_headers = request_body.get('headers', {})
            for arg_name, arg_type in service_impl.method_args.get(method_name, {}).items():
                if arg_name not in method_args:
                    if arg_name not in method_headers:
                        raise WebRPCError(f"Missing argument '{arg_name}'")
                    method_args[arg_name] = method_headers[arg_name]
                if not validate_type(method_args[arg_name], arg_type):
                    raise WebRPCError(f"Invalid argument '{arg_name}'")

            response = method_impl(method_args)

            method_returns = service_impl.method_returns.get(method_name, {})
            for return_name, return_type in method_returns.items():
                if return_name not in response:
                    raise WebRPCError("Internal server error", 500)
                if not validate_type(response[return_name], return_type):
                    raise WebRPCError("Internal server error", 500)

            self._send_response(response)
        except WebRPCError as err:
            status_code = err.status_code or 400
            response = {
                'msg': err.message,
                'status': status_code,
                'code': '',
            }
            self._send_response(response, status_code)
        except Exception as err:
            self._send_response(str(err), 400)

    def do_POST(self):
        path_parts = self.path.strip('/').split('/')
        if len(path_parts) != 2:
            self.send_error(404)
            return

        service_name, method_name = path_parts
        if not service_name or not method_name:
            self.send_error(404)
            return

        if self.headers.get('Content-Type') != 'application/json':
            self.send_error(415)
            return

        try:
            request_body = self._parse_request_body()
            self._handle_rpc_request(service_name, method_name, request_body)
        except Exception as err:
            self.send_error(400, str(err))

def create_server(service_implementation, hostname='localhost', port=8080):
    server_address = (hostname, port)
    server = HTTPServer(server_address, WebRPCRequestHandler)
    server.service_implementation = service_implementation
    return server



def create_TestApi_app(service_implementation):
    return create_server(TestApi(), service_implementation)


TYPE_VALIDATORS: typing.Dict[str, Callable[[any], bool]] = {}

TYPE_VALIDATORS = {
    
}

PY_TYPES = [
    "bool",
    "int",
    "float",
    "str",
    "list",
    "tuple",
    "dict",
    "NoneType"
]

def validate_type(value, type):
    if type in PY_TYPES:
        return isinstance(value, type)

    if type == "function":
        return callable(value)

    validator = TYPE_VALIDATORS.get(type)

    if not validator:
        return False

    return validator(value)